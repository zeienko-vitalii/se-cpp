# Тема 4: Статичні методи, перевантаження операторів та методів. {#mainpage}

## Мета

Навчитись доречно використовувати статичні методи, а також використовувати перевантаження методів та операторів.

## 1. Загальне завдання
Необхідно визначити у класі *View1* статичний метод *OnTimerAction()*. Цей метод відображатиме на екрані 
заданий нащадок *Data1*.
Обрати для Win32-таймера власний інтервал повторних викликів. Встановити реалізований метод *View1::OnTimerAction()*
на виклик у таймері. Таймер повинен спрацювати лише 4 рази. Метод повинен виводити на екран дані про поточний асоційований 
об'єкт даних.
Додаткові 4 бали додаються пр иокремій реалізації класу для роботи із таймером.
Реалізувати перевантажені опреатори та методи згідно індивідуального завдання.
Варіант 3.
1. Предметна область: Мишки.
2. Перевантаженні методи SetData();
3. Перевантажені оператори: 
- bool Data1::operator == (const Data1&), котрий повертає true, якщо тип пристрою та кількість кнопок співпадає.
- bool Data2::operator == (const Data2&), котрий повертає true, якщо усі параметри порівнюваних об'єктів співпадають.
- Data2::operator = (int) встановлює тип сенсора, який допустимий для цього класу. У разі недопустимого значення присвоєння не відбувається 
і залишається попереднє значення.

## 2. Розробка пограми
### 2.1. Засоби ООП
У розробленій програмі були використані наступні засоби ООП: <br>
- інкапсуляція
- спадкування
- поліморфізм
<br>

### 2.2. Ієрархія та структура класів
На рис. 2.1 наведена ієрархія зв'язків класу BaseView, на рис. 2.2 - Manipulator, а на рисунку 2.3 - Event.
<br>

Hierarchy of BaseView class |
---------- |
![img_HierarchyFormBaseView](/html/screenshot/hierarchy_classBV.png)|
Рисунок 2.1 - Ієрархія зв'язків класу BaseView|
<br>

Hierarchy of Manipualtor class|
---------- |
![img_HierarchyFromManipulator](/html/screenshot/hierarchy_classManipulator.png)|
Рисунок 2.2 - Ієрархія зв'язків класу Manipulator|
<br>

Hierarchy of Event class|
---------- |
![img_HierarchyFromManipulator](/html/screenshot/hierarchy_classEvent.png)|
Рисунок 2.3 -Ієрархія зв'язків класу Event|
<br>

### 2.3. Опис програми
На рисунку 2.4 наведена структура розробленого проекту: 

Project structure |
---------- |
![img_project_struct](/html/screenshot/project.png)|
Рисунок 2.4 - Структура проект|
 
### 2.4. Важливі фрагменти програми
Демонстрація перевантажених операторів та спрацьовування таймера наведена на рисунку 2.5 та рисунку 2.6 відповідно.

Демонстрація перевантажених операторів |
---------- |
![img_main](/html/screenshot/operatorOverloadingFunc.png)|
Рисунок 2.5. – Функція operatorOverloadingDemonstration() |

Демонстрація спрацьовування таймера |
---------- |
![img_main](/html/screenshot/timerFunc.png)|
Рисунок 2.6. – Функція timerDemonstration() |

Для даного проекту були розроблені модульні тести за допомогою GoogleTest Framework.
Ці тести перевіряють працювання перевантажених операторів. Результат роботи тестів зображений на рисунку 3.2 п. Результат роботи

Призначення спроектованих класів наведено на рис. 2.7. 

Predestination structure |
---------- |
![img_predestination_of_classes](/html/screenshot/class_description.png)|
Рисунок 2.7. – Призначення спроектованих класів|

## 3. Результат работи
Результат роботи програми зображений на рисунку 3.1.

Output to the console |
---------- |
![img_result](/html/screenshot/result.png)|
Рисунок 3.1. – Результат виконання програми|

Результат виконання всіх модульних тестів зображений на рисунку 3.2.
Тести відсортировані за класом тестування.

Unit Tests Result |
---------- |
![img_unitTest_result](/html/screenshot/unitTest.png)|
Рисунок 3.2. – Результат тестування|

Було усунуто витоки пам'яті. Код завершення програми зображений на рисунку 3.3

Program completion code |
---------- |
![img_unitTest_result](/html/screenshot/outputWindow.png)|
Рисунок 3.3. – Результат тестування|


## Висновок
В ході виконання лабораторної роботи були отримані навики розробки власних ієрархій класів із використанням принципу розширення та віртуальності.
