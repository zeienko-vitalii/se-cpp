# Лабораторна робота № 1: Стекові об'єкти. Конструктор, деструктор, відображення, передача

## Мета 
Навчитись створювати об'єкти. Отримати розуміння створення об'єкта на стеку а також передачу об'єкту по значенню.
## 1.ІНДИВІДУАЛЬНЕ ЗАВДАННЯ
Створити клас даних `Wheel` та класс відображення даних - `Screen`. Об'єкт відображення конструюється на стеку функції `main()` об'єктом даних, що заздалегіть створений на стеку. Передавати `Wheel` як значення.
`Wheel` має всі публічні поля та методи. `Screen` лише виконує відображення даних у формі `<назва поля>=<значення>;` всі його методи та атрибути публічні.

## 2.РОЗРОБКА ПРОГРАМИ
### 2.1 Засоби ООП
В ході розробки програми були використані такі засоби ООП:
- Абстракція - кожен об'єкт описує свою особливу сутність, яка визначається його полями.
- Інкапсуляція - поля об'єктів закриті для користувача,натомість ми даємо доступ до даних за допомогою геттерів та сеттерів, так користувач має можливість отримати готові дані, а не обробляти їх, для подпльшого вікористання. 

### 2.2 Іерархія та структура класів
На рис 2.1 дивись іерархію класів


<p align="center">

![Іерархія класів](https://raw.githubusercontent.com/kit25a/se-cpp/master/shandalovych-viktoriia/doc/shandalovych01/screen/classGraph.png)

 Рисунок 2.1 іерархія класів
</p>


### 2.3 Опис програми
На рис 2.2 дивись структуру проекту.





<p align="center">

![структурa проекту](https://github.com/kit25a/se-cpp/blob/master/shandalovych-viktoriia/doc/shandalovych01/screen/projectStruct.PNG?raw=true)
 Рисунок 2.2 структурa проекту
</p>

На рис 2.3 дивись призначення класів.


<p align="center">

![призначення класів](https://raw.githubusercontent.com/kit25a/se-cpp/master/shandalovych-viktoriia/doc/shandalovych01/screen/classes.PNG)
 Рисунок 2.3 призначення класів
</p>

Ми маємо 2 класа: Вікно `Window` та Відображувач `Screen`. Вікно описує сутність програмного вікна, тобто його id та координати, а відображувач використовуєсться для виводу даних з об'єкту вікна у консоль. У функції `main()` відображена робота програми.

### 2.4 Важливі фрагменти програми
У программі слід зауважити увагу на таких моментах:
#### Класс ` Wheel.cpp` списки ініціалізації 

```
Wheel::Wheel(int diameter, int width, string unit): diameter(diameter), unit(unit), width(width) {
	cout << "Вызов коструктора с параметром\n";

}
```

#### Класс ` Screen.cpp` вивід інформації у консоль:

``` void Screen::ViewWheel() {

	cout << "diameter = " << wheel.getdiameter() << "\n";
	cout << "unit = " << wheel.getunit() << "\n";
	cout << "width = " << wheel.getwidth() << "\n";
}

```


#### Класс `main.cpp ` демонстрація роботи

```
int main(void) {

	//Константы для инициализации первого объекта.
	const int diameter = 20;
	const int width = 10;
	const string unit = "см";
	

	Wheel data( diameter, width, unit);

	Screen screen(data);

	screen.ViewWheel();

	return 0;
}
```






## 3.РЕЗУЛЬТАТИ РОБОТИ


Результат роботи показано на рис 3.1.


<p align="center">

![призначення класів](https://github.com/kit25a/se-cpp/blob/master/shandalovych-viktoriia/doc/shandalovych01/screen/res1.PNG?raw=true)
 Рисунок 3.1 призначення класів
</p>

##ВИСНОВКИ
В результаті виконання лабораторної роботи мною були придбані навички програмування з використання алгоритмів STL, використання наслідування класу. Вважаю, що мета роботи була досягнута.